-- Schema
CREATE SCHEMA IF NOT EXISTS identity;

-- Custom types
create type identity.app_permission as enum (
  'identity.users.admin', 'identity.users.read', 'identity.users.insert', 'identity.users.update', 'identity.users.delete',
  'identity.user_roles.admin', 'identity.user_roles.read', 'identity.user_roles.insert', 'identity.user_roles.update', 'identity.user_roles.delete',
  'identity.role_permissions.admin', 'identity.role_permissions.read', 'identity.role_permissions.insert', 'identity.role_permissions.update', 'identity.role_permissions.delete',
  'finance.purchase.admin', 'finance.purchase.read', 'finance.purchase.insert', 'finance.purchase.update', 'finance.purchase.delete',
  'finance.receipt.admin', 'finance.receipt.read', 'finance.receipt.insert', 'finance.receipt.update', 'finance.receipt.delete',
  'finance.expense_category.admin', 'finance.expense_category.read', 'finance.expense_category.insert', 'finance.expense_category.update', 'finance.expense_category.delete',
  'finance.expense_type.admin', 'finance.expense_type.read', 'finance.expense_type.insert', 'finance.expense_type.update', 'finance.expense_type.delete',
  'finance.currency.admin', 'finance.currency.read', 'finance.currency.insert', 'finance.currency.update', 'finance.currency.delete'
  );
create type identity.app_role as enum ('admin', 'financeadmin', 'employee');

-- USERS
create table identity.users (
  id          uuid references auth.users not null primary key, -- UUID from auth.users
  username    text,
  actor_key text UNIQUE,
  is_active BOOLEAN DEFAULT TRUE,
  is_system boolean DEFAULT false,
  created_by uuid references identity.users(id) on delete set null DEFAULT auth.uid(),
  created_at timestamptz DEFAULT now(),
  updated_by uuid references identity.users(id) on delete set null,
  updated_at timestamptz DEFAULT now()
);
comment on table identity.users is 'Profile data for each user.';
comment on column identity.users.id is 'References the internal Supabase Auth user.';
CREATE UNIQUE INDEX IF NOT EXISTS identity_users_actor_key_idx ON identity.users (actor_key) WHERE actor_key IS NOT NULL;

-- USER ROLES
create table identity.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references identity.users on delete cascade not null,
  role      identity.app_role not null,
  unique (user_id, role),
  is_active BOOLEAN DEFAULT TRUE,
  created_by uuid references identity.users(id) on delete set null DEFAULT auth.uid(),
  created_at timestamptz DEFAULT now(),
  updated_by uuid references identity.users(id) on delete set null,
  updated_at timestamptz DEFAULT now()
);
comment on table identity.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table identity.role_permissions (
  id           bigint generated by default as identity primary key,
  role         identity.app_role not null,
  permission   identity.app_permission not null,
  unique (role, permission),
  is_active BOOLEAN DEFAULT TRUE,
  created_by uuid references identity.users(id) on delete set null DEFAULT auth.uid(),
  created_at timestamptz DEFAULT now(),
  updated_by uuid references identity.users(id) on delete set null,
  updated_at timestamptz DEFAULT now()
);
comment on table identity.role_permissions is 'Application permissions for each role.';

-- authorize with role-based access control (RBAC)
create or replace function identity.authorize(
  requested_permission identity.app_permission
)
returns boolean
language plpgsql
security definer
as $$
begin
  return exists (
    select 1
    from identity.role_permissions rp
    where rp.permission = requested_permission
      and rp.role = (auth.jwt() ->> 'user_role')::identity.app_role
      and rp.is_active
  );
end;
$$;


-- add permissions
-- Finance permissions
insert into identity.role_permissions (role, permission)
values
  -- finance.purchase
  ('financeadmin', 'finance.purchase.admin'),
  ('financeadmin', 'finance.purchase.read'),
  ('financeadmin', 'finance.purchase.insert'),
  ('financeadmin', 'finance.purchase.update'),
  ('financeadmin', 'finance.purchase.delete'),
  ('employee',     'finance.purchase.read'),
  ('employee',     'finance.purchase.insert'),
  ('employee',     'finance.purchase.update'),
  ('employee',     'finance.purchase.delete'),

  -- finance.receipt
  ('financeadmin', 'finance.receipt.admin'),
  ('financeadmin', 'finance.receipt.read'),
  ('financeadmin', 'finance.receipt.insert'),
  ('financeadmin', 'finance.receipt.update'),
  ('financeadmin', 'finance.receipt.delete'),
  ('employee',     'finance.receipt.read'),
  ('employee',     'finance.receipt.insert'),
  ('employee',     'finance.receipt.update'),
  ('employee',     'finance.receipt.delete'),

  -- finance.expense_category
  ('financeadmin', 'finance.expense_category.admin'),
  ('financeadmin', 'finance.expense_category.read'),
  ('financeadmin', 'finance.expense_category.insert'),
  ('financeadmin', 'finance.expense_category.update'),
  ('financeadmin', 'finance.expense_category.delete'),
  ('employee',     'finance.expense_category.read'),

  -- finance.expense_type
  ('financeadmin', 'finance.expense_type.admin'),
  ('financeadmin', 'finance.expense_type.read'),
  ('financeadmin', 'finance.expense_type.insert'),
  ('financeadmin', 'finance.expense_type.update'),
  ('financeadmin', 'finance.expense_type.delete'),
  ('employee',     'finance.expense_type.read'),

  -- finance.currency
  ('financeadmin', 'finance.currency.admin'),
  ('financeadmin', 'finance.currency.read'),
  ('financeadmin', 'finance.currency.insert'),
  ('financeadmin', 'finance.currency.update'),
  ('financeadmin', 'finance.currency.delete'),
  ('employee',     'finance.currency.read');

-- Admin role permissions
insert into identity.role_permissions (role, permission)
values
  ('admin', 'identity.users.admin'),
  ('admin', 'identity.users.read'),
  ('admin', 'identity.users.insert'),
  ('admin', 'identity.users.update'),
  ('admin', 'identity.users.delete'),
  ('admin', 'identity.user_roles.admin'),
  ('admin', 'identity.user_roles.read'),
  ('admin', 'identity.user_roles.insert'),
  ('admin', 'identity.user_roles.update'),
  ('admin', 'identity.user_roles.delete'),
  ('admin', 'identity.role_permissions.admin'),
  ('admin', 'identity.role_permissions.read'),
  ('admin', 'identity.role_permissions.insert'),
  ('admin', 'identity.role_permissions.update'),
  ('admin', 'identity.role_permissions.delete');

-- Secure the tables
alter table identity.users enable row level security;
alter table identity.user_roles enable row level security;
alter table identity.role_permissions enable row level security;


-- Identity: users
DROP POLICY IF EXISTS "Allow logged-in read or admin" ON identity.users;
create policy "Allow logged-in read or admin read" on identity.users for select using (
  auth.role() = 'authenticated' or identity.authorize('identity.users.admin') and is_active = true
);
DROP POLICY IF EXISTS "Allow insert for self or admin" ON identity.users;
create policy "Allow insert for self or admin" on identity.users for insert with check (
  (auth.uid())::uuid = id or identity.authorize('identity.users.admin')
);
DROP POLICY IF EXISTS "Allow update for self or admin" ON identity.users;
create policy "Allow update for self or admin" on identity.users for update with check (
  ( (auth.uid())::uuid = id and is_active = true )
  or ( identity.authorize('identity.users.admin') and is_active = true )
);
DROP POLICY IF EXISTS "Allow soft delete for self or admin" ON identity.users;
create policy "Allow soft delete for self or admin" on identity.users for update with check (
  ( (auth.uid())::uuid = id and is_active = false )
  or ( identity.authorize('identity.users.admin') and is_active = false )
);


-- Identity: user_roles
DROP POLICY IF EXISTS "Allow read for self or admin" ON identity.user_roles;
create policy "Allow read for self or admin" on identity.user_roles for select using (
  (auth.uid())::uuid = user_id or identity.authorize('identity.user_roles.admin') and is_active = true
);
DROP POLICY IF EXISTS "Allow insert for self or admin" ON identity.user_roles;
create policy "Allow insert for self or admin" on identity.user_roles for insert with check (
  identity.authorize('identity.user_roles.admin')
);
DROP POLICY IF EXISTS "Allow update for self or admin" ON identity.user_roles;
create policy "Allow update for self or admin" on identity.user_roles for update with check (
  identity.authorize('identity.user_roles.admin') and is_active = true
);
DROP POLICY IF EXISTS "Allow soft delete for self or admin" ON identity.user_roles;
create policy "Allow soft delete for self or admin" on identity.user_roles for update with check (
  identity.authorize('identity.user_roles.admin') and is_active = false
);

-- Finance: purchase
DROP POLICY IF EXISTS "Allow read for self or admin" ON finance.purchase;
create policy "Allow read for self or admin" on finance.purchase for select using (
  ( (auth.uid())::uuid = created_by and identity.authorize('finance.purchase.read') and is_active = true )
  or identity.authorize('finance.purchase.admin')
);
DROP POLICY IF EXISTS "Allow insert for self or admin" ON finance.purchase;
CREATE POLICY "Allow insert for self or admin" ON finance.purchase FOR INSERT WITH CHECK (
    ( (auth.uid())::uuid = created_by AND identity.authorize('finance.purchase.insert') ) 
    OR identity.authorize('finance.purchase.admin')
);
DROP POLICY IF EXISTS "Allow update for self or admin" ON finance.purchase;
create policy "Allow update for self or admin" on finance.purchase
FOR UPDATE
USING (
    is_active = true AND 
    ( (auth.uid())::uuid = created_by AND identity.authorize('finance.purchase.update') )
    OR identity.authorize('finance.purchase.admin')
)
WITH CHECK (
    ( (auth.uid())::uuid = created_by AND identity.authorize('finance.purchase.update') )
    OR identity.authorize('finance.purchase.admin')
);
DROP POLICY IF EXISTS "Allow soft delete for self or admin" ON finance.purchase;
create policy "Allow soft delete for self or admin" on finance.purchase
FOR UPDATE
USING (
    is_active = true AND 
    ( (auth.uid())::uuid = created_by AND identity.authorize('finance.purchase.delete') )
    OR identity.authorize('finance.purchase.admin')
)
WITH CHECK (
    ( (auth.uid())::uuid = created_by AND is_active = false AND identity.authorize('finance.purchase.delete') )
    OR identity.authorize('finance.purchase.admin')
);

-- Finance: receipt
DROP POLICY IF EXISTS "Allow read for self or admin" ON finance.receipt;
create policy "Allow read for self or admin" on finance.receipt for select using (
  ( (auth.uid())::uuid = created_by and identity.authorize('finance.receipt.read') and is_active = true )
  or identity.authorize('finance.receipt.admin')
);
DROP POLICY IF EXISTS "Allow insert for self or admin" ON finance.receipt;
CREATE POLICY "Allow insert for self or admin" ON finance.receipt FOR INSERT WITH CHECK (
    ( (auth.uid())::uuid = created_by AND identity.authorize('finance.receipt.insert') ) 
    OR identity.authorize('finance.receipt.admin')
);
DROP POLICY IF EXISTS "Allow update for self or admin" ON finance.receipt;
create policy "Allow update for self or admin" on finance.receipt
FOR UPDATE
USING (
    is_active = true AND 
    ( (auth.uid())::uuid = created_by AND identity.authorize('finance.receipt.update') )
    OR identity.authorize('finance.receipt.admin')
)
WITH CHECK (
    ( (auth.uid())::uuid = created_by AND identity.authorize('finance.receipt.update') )
    OR identity.authorize('finance.receipt.admin')
);
DROP POLICY IF EXISTS "Allow soft delete for self or admin" ON finance.receipt;
create policy "Allow soft delete for self or admin" on finance.receipt
FOR UPDATE
USING (
    is_active = true AND 
    ( (auth.uid())::uuid = created_by AND identity.authorize('finance.receipt.delete') )
    OR identity.authorize('finance.receipt.admin')
)
WITH CHECK (
    ( (auth.uid())::uuid = created_by AND is_active = false AND identity.authorize('finance.receipt.delete') )
    OR identity.authorize('finance.receipt.admin')
);

-- Finance: expense_category
DROP POLICY IF EXISTS "Allow read for self or admin" ON finance.expense_category;
create policy "Allow read for self or admin" on finance.expense_category for select using (
  is_active = true AND (
    ( auth.role() = 'authenticated' and identity.authorize('finance.expense_category.read') )
    or identity.authorize('finance.expense_category.admin')
  )
);
DROP POLICY IF EXISTS "Allow insert for self or admin" ON finance.expense_category;
create policy "Allow insert for self or admin" on finance.expense_category for insert with check (
  identity.authorize('finance.expense_category.admin')
);
DROP POLICY IF EXISTS "Allow update for admin only" ON finance.expense_category;
create policy "Allow update for admin only" on finance.expense_category
FOR UPDATE USING (
    identity.authorize('finance.expense_category.admin') AND is_active = true
) WITH CHECK (
    identity.authorize('finance.expense_category.admin') AND is_active = true
);
DROP POLICY IF EXISTS "Allow soft delete for admin only" ON finance.expense_category;
create policy "Allow soft delete for admin only" on finance.expense_category
FOR UPDATE USING (
    identity.authorize('finance.expense_category.admin') AND is_active = true
) WITH CHECK (
    identity.authorize('finance.expense_category.admin') AND is_active = false
);

-- Finance: expense_type
DROP POLICY IF EXISTS "Allow read for self or admin" ON finance.expense_type;
create policy "Allow read for self or admin" on finance.expense_type for select using (
  is_active = true AND (
    ( auth.role() = 'authenticated' and identity.authorize('finance.expense_type.read') )
    or identity.authorize('finance.expense_type.admin')
  )
);
DROP POLICY IF EXISTS "Allow insert for self or admin" ON finance.expense_type;
create policy "Allow insert for self or admin" on finance.expense_type for insert with check (
  identity.authorize('finance.expense_type.admin')
);
DROP POLICY IF EXISTS "Allow update for admin only" ON finance.expense_type;
create policy "Allow update for admin only" on finance.expense_type
FOR UPDATE USING (
    identity.authorize('finance.expense_type.admin') AND is_active = true
) WITH CHECK (
    identity.authorize('finance.expense_type.admin') AND is_active = true
);
DROP POLICY IF EXISTS "Allow soft delete for admin only" ON finance.expense_type;
create policy "Allow soft delete for admin only" on finance.expense_type
FOR UPDATE USING (
    identity.authorize('finance.expense_type.admin') AND is_active = true
) WITH CHECK (
    identity.authorize('finance.expense_type.admin') AND is_active = false
);

-- Finance: currency
DROP POLICY IF EXISTS "Allow read for self or admin" ON finance.currency;
create policy "Allow read for self or admin" on finance.currency for select using (
  is_active = true AND (
    ( auth.role() = 'authenticated' and identity.authorize('finance.currency.read') )
    or identity.authorize('finance.currency.admin')
  )
);
DROP POLICY IF EXISTS "Allow insert for self or admin" ON finance.currency;
create policy "Allow insert for self or admin" on finance.currency for insert with check (
  identity.authorize('finance.currency.admin')
);
DROP POLICY IF EXISTS "Allow update for admin only" ON finance.currency;
create policy "Allow update for admin only" on finance.currency
FOR UPDATE USING (
    identity.authorize('finance.currency.admin') AND is_active = true
) WITH CHECK (
    identity.authorize('finance.currency.admin') AND is_active = true
);
DROP POLICY IF EXISTS "Allow soft delete for admin only" ON finance.currency;
create policy "Allow soft delete for admin only" on finance.currency
FOR UPDATE USING (
    identity.authorize('finance.currency.admin') AND is_active = true
) WITH CHECK (
    identity.authorize('finance.currency.admin') AND is_active = false
);

-- inserts a row into identity.users and assigns roles
create or replace function identity.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = auth, identity
as $$
declare
  is_admin boolean;
begin
  insert into identity.users (id, username)
  values (new.id, new.email);

  select exists (
    select 1 from auth.users
  ) into is_admin;

  -- You can now use is_admin to assign roles, log, etc.

  return new;
end;
$$;


-- trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure identity.handle_new_user();


/**
 * HELPER FUNCTIONS
 * Create test user helper method.
 */
create or replace function identity.create_user(
    email text
) returns uuid
    security definer
    set search_path = auth
as $$
  declare
  user_id uuid;
begin
  user_id := extensions.uuid_generate_v4();
  
  insert into auth.users (id, email)
    values (user_id, email)
    returning id into user_id;

    return user_id;
end;
$$ language plpgsql;
