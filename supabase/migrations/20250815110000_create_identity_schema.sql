-- Schema
CREATE SCHEMA IF NOT EXISTS identity;

-- Custom types
create type identity.app_permission as enum (
  'identity.users.admin', 'identity.users.read', 'identity.users.insert', 'identity.users.update', 'identity.users.delete',
  'identity.role_permissions.admin', 'identity.role_permissions.read', 'identity.role_permissions.insert', 'identity.role_permissions.update', 'identity.role_permissions.delete',
  'finance.purchase.admin', 'finance.purchase.read', 'finance.purchase.insert', 'finance.purchase.update', 'finance.purchase.delete',
  'finance.receipt.admin', 'finance.receipt.read', 'finance.receipt.insert', 'finance.receipt.update', 'finance.receipt.delete',
  'finance.expense_category.admin', 'finance.expense_category.read', 'finance.expense_category.insert', 'finance.expense_category.update', 'finance.expense_category.delete',
  'finance.expense_type.admin', 'finance.expense_type.read', 'finance.expense_type.insert', 'finance.expense_type.update', 'finance.expense_type.delete',
  'finance.currency.admin', 'finance.currency.read', 'finance.currency.insert', 'finance.currency.update', 'finance.currency.delete'
  );
create type identity.app_role as enum ('admin', 'financeadmin', 'employee');

-- USERS
create table identity.users (
  id          uuid references auth.users not null primary key, -- UUID from auth.users
  username    text,
  actor_key text UNIQUE,
  deleted_at timestamptz DEFAULT NULL,
  is_system boolean DEFAULT false,
  created_by uuid references identity.users(id) on delete set null DEFAULT auth.uid(),
  created_at timestamptz DEFAULT now(),
  updated_by uuid references identity.users(id) on delete set null,
  updated_at timestamptz DEFAULT now()
);
comment on table identity.users is 'Profile data for each user.';
comment on column identity.users.id is 'References the internal Supabase Auth user.';
CREATE UNIQUE INDEX IF NOT EXISTS identity_users_actor_key_idx ON identity.users (actor_key) WHERE actor_key IS NOT NULL;

-- ORGANIZATIONS (tenants)
create table if not exists identity.org (
  id          uuid primary key default gen_random_uuid(),
  name        text not null,
  slug        text not null unique,
  settings    jsonb not null default '{}'::jsonb,
  deleted_at  timestamptz DEFAULT NULL,
  created_by  uuid references identity.users(id) on delete set null,
  created_at  timestamptz not null default now(),
  updated_by  uuid references identity.users(id) on delete set null,
  updated_at  timestamptz not null default now()
);

comment on table identity.org is 'Organizations / tenants.';

-- Helper: current org id from JWT (used by finance RLS policies)
create or replace function identity.current_org_id()
returns uuid
language sql
stable
as $$
  select nullif(auth.jwt() ->> 'org_id', '')::uuid;
$$;

-- NOTE: org-level roles are stored in identity.member_role (created in 20251222163200_multitenancy_orgs.sql)

-- ROLE PERMISSIONS
create table identity.role_permissions (
  id           bigint generated by default as identity primary key,
  role         identity.app_role not null,
  permission   identity.app_permission not null,
  unique (role, permission),
  deleted_at timestamptz DEFAULT NULL,
  created_by uuid references identity.users(id) on delete set null DEFAULT auth.uid(),
  created_at timestamptz DEFAULT now(),
  updated_by uuid references identity.users(id) on delete set null,
  updated_at timestamptz DEFAULT now()
);
comment on table identity.role_permissions is 'Application permissions for each role.';

-- authorize with role-based access control (RBAC)
-- NOTE: multi-tenancy migration overrides this function to support multi-role claims.
create or replace function identity.authorize(
  requested_permission identity.app_permission
)
returns boolean
language plpgsql
security definer
as $$
begin
  return exists (
    select 1
    from identity.role_permissions rp
    where rp.permission = requested_permission
      and rp.role = (auth.jwt() ->> 'user_role')::identity.app_role
      and rp.deleted_at IS NULL
  );
end;
$$;


-- add permissions
-- Finance permissions
insert into identity.role_permissions (role, permission)
values
  -- finance.purchase
  ('financeadmin', 'finance.purchase.admin'),
  ('financeadmin', 'finance.purchase.read'),
  ('financeadmin', 'finance.purchase.insert'),
  ('financeadmin', 'finance.purchase.update'),
  ('financeadmin', 'finance.purchase.delete'),
  ('employee',     'finance.purchase.read'),
  ('employee',     'finance.purchase.insert'),
  ('employee',     'finance.purchase.update'),
  ('employee',     'finance.purchase.delete'),

  -- finance.receipt
  ('financeadmin', 'finance.receipt.admin'),
  ('financeadmin', 'finance.receipt.read'),
  ('financeadmin', 'finance.receipt.insert'),
  ('financeadmin', 'finance.receipt.update'),
  ('financeadmin', 'finance.receipt.delete'),
  ('employee',     'finance.receipt.read'),
  ('employee',     'finance.receipt.insert'),
  ('employee',     'finance.receipt.update'),
  ('employee',     'finance.receipt.delete'),

  -- finance.expense_category
  ('financeadmin', 'finance.expense_category.admin'),
  ('financeadmin', 'finance.expense_category.read'),
  ('financeadmin', 'finance.expense_category.insert'),
  ('financeadmin', 'finance.expense_category.update'),
  ('financeadmin', 'finance.expense_category.delete'),
  ('employee',     'finance.expense_category.read'),

  -- finance.expense_type
  ('financeadmin', 'finance.expense_type.admin'),
  ('financeadmin', 'finance.expense_type.read'),
  ('financeadmin', 'finance.expense_type.insert'),
  ('financeadmin', 'finance.expense_type.update'),
  ('financeadmin', 'finance.expense_type.delete'),
  ('employee',     'finance.expense_type.read'),

  -- finance.currency
  ('financeadmin', 'finance.currency.admin'),
  ('financeadmin', 'finance.currency.read'),
  ('financeadmin', 'finance.currency.insert'),
  ('financeadmin', 'finance.currency.update'),
  ('financeadmin', 'finance.currency.delete'),
  ('employee',     'finance.currency.read');

-- Admin role permissions
insert into identity.role_permissions (role, permission)
values
  ('admin', 'identity.users.admin'),
  ('admin', 'identity.users.read'),
  ('admin', 'identity.users.insert'),
  ('admin', 'identity.users.update'),
  ('admin', 'identity.users.delete'),
  -- identity.user_roles.* permissions removed (org membership roles are handled via identity.org_member/member_role)
  ('admin', 'identity.role_permissions.admin'),
  ('admin', 'identity.role_permissions.read'),
  ('admin', 'identity.role_permissions.insert'),
  ('admin', 'identity.role_permissions.update'),
  ('admin', 'identity.role_permissions.delete');

-- Secure the tables
alter table identity.users enable row level security;
alter table identity.role_permissions enable row level security;


-- ============================================================================
-- RLS POLICIES: identity.users
-- ============================================================================

CREATE POLICY "Allow logged-in read or admin read" ON identity.users 
FOR SELECT USING (
  auth.role() = 'authenticated' OR identity.authorize('identity.users.admin')
);

CREATE POLICY "Allow insert for self or admin" ON identity.users 
FOR INSERT WITH CHECK (
  (auth.uid())::uuid = id OR identity.authorize('identity.users.admin')
);

CREATE POLICY "Allow update and soft delete (self or admin)" ON identity.users
FOR UPDATE
USING (
  -- Minimal target-set
  (auth.uid())::uuid = id OR identity.authorize('identity.users.admin')
)
WITH CHECK (
  (
    -- Admin can do anything
    identity.authorize('identity.users.admin')
    -- OR self: choose path based on final deleted_at
    OR (
      (auth.uid())::uuid = id
      AND (
        -- Update path: deleted_at stays NULL
        deleted_at IS NULL
        -- Delete path: deleted_at becomes NOT NULL
        OR deleted_at IS NOT NULL
      )
    )
  )
);


-- NOTE: identity.user_roles table removed

-- inserts a row into identity.users and assigns roles
create or replace function identity.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = auth, identity
as $$
declare
  is_admin boolean;
begin
  insert into identity.users (id, username)
  values (new.id, new.email);

  select exists (
    select 1 from auth.users
  ) into is_admin;

  -- You can now use is_admin to assign roles, log, etc.

  return new;
end;
$$;


-- trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure identity.handle_new_user();


/**
 * HELPER FUNCTIONS
 * Create test user helper method.
 */
create or replace function identity.create_user(
    email text
) returns uuid
    security definer
    set search_path = auth
as $$
  declare
  user_id uuid;
begin
  user_id := extensions.uuid_generate_v4();
  
  insert into auth.users (id, email)
    values (user_id, email)
    returning id into user_id;

    return user_id;
end;
$$ language plpgsql;

-- Grants to the service role
GRANT USAGE ON SCHEMA identity TO service_role;  -- equivalent elevated role
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA identity TO service_role;
ALTER DEFAULT PRIVILEGES IN SCHEMA identity
  GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO service_role;

-- Grants to authenticated users (RLS policies control actual access)
-- Note: SELECT permission on views only (granted above for users_read)
GRANT USAGE ON SCHEMA identity TO authenticated;
GRANT INSERT, UPDATE ON ALL TABLES IN SCHEMA identity TO authenticated;
ALTER DEFAULT PRIVILEGES IN SCHEMA identity
  GRANT INSERT, UPDATE ON TABLES TO authenticated;
