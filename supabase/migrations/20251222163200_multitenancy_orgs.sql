-- Multi-tenancy: Organizations + Memberships + Per-org roles
-- Date: 2025-12-22

begin;

-- -----------------------------------------------------------------------------
-- identity.users: platform admin flag
-- -----------------------------------------------------------------------------
alter table if exists identity.users
  add column if not exists is_platform_admin boolean not null default false;

-- Ensure we can enforce per-org reference data uniqueness by (org_id, id)
-- (IDs are seeded deterministically today; without this, an upsert would update the wrong org)

-- org-scoped unique indexes for deterministic IDs
create unique index if not exists finance_currency_org_id_id_uniq
  on finance.currency (org_id, id);

create unique index if not exists finance_expense_category_org_id_id_uniq
  on finance.expense_category (org_id, id);

create unique index if not exists finance_expense_type_org_id_id_uniq
  on finance.expense_type (org_id, id);

-- -----------------------------------------------------------------------------
-- identity.org
-- -----------------------------------------------------------------------------
-- NOTE: identity.org is created in 20250815110000_create_identity_schema.sql (needed early for finance FK).

-- -----------------------------------------------------------------------------
-- identity.org_member
-- -----------------------------------------------------------------------------
create table if not exists identity.org_member (
  id          bigint generated by default as identity primary key,
  org_id      uuid not null references identity.org(id) on delete cascade,
  user_id     uuid not null references identity.users(id) on delete cascade,
  is_owner    boolean not null default false,
  is_active   boolean not null default true,
  created_by  uuid references identity.users(id) on delete set null,
  created_at  timestamptz not null default now(),
  updated_by  uuid references identity.users(id) on delete set null,
  updated_at  timestamptz not null default now(),
  unique (org_id, user_id)
);

comment on table identity.org_member is 'Membership of a user in an organization.';

-- -----------------------------------------------------------------------------
-- identity.member_role (per-org roles)
-- -----------------------------------------------------------------------------
create table if not exists identity.member_role (
  id          bigint generated by default as identity primary key,
  member_id   bigint not null references identity.org_member(id) on delete cascade,
  role        identity.app_role not null,
  is_active   boolean not null default true,
  created_by  uuid references identity.users(id) on delete set null,
  created_at  timestamptz not null default now(),
  updated_by  uuid references identity.users(id) on delete set null,
  updated_at  timestamptz not null default now(),
  unique (member_id, role)
);

comment on table identity.member_role is 'Roles assigned to an org member (user can have multiple roles per org).';

-- -----------------------------------------------------------------------------
-- Org scoping columns
-- -----------------------------------------------------------------------------
-- NOTE: org_id columns are created in 20250815120000_create_finance_schema.sql so that
-- finance policies (20250815130000_finance_tables_policies.sql) can reference them.

-- -----------------------------------------------------------------------------
-- Helper functions (JWT org context)
-- -----------------------------------------------------------------------------
-- NOTE: identity.current_org_id() is created in 20250815110000_create_identity_schema.sql (needed early for finance RLS).

create or replace function identity.current_member_id()
returns bigint
language sql
stable
as $$
  select nullif(auth.jwt() ->> 'member_id', '')::bigint;
$$;

-- -----------------------------------------------------------------------------
-- Update authorize() to support multi-role claim: user_roles: ["employee", ...]
-- -----------------------------------------------------------------------------
create or replace function identity.authorize(
  requested_permission identity.app_permission
)
returns boolean
language plpgsql
security definer
as $$
declare
  roles_text text[];
begin
  -- If claim missing, deny
  if (auth.jwt() -> 'user_roles') is null then
    return false;
  end if;

  select coalesce(array_agg(x), '{}'::text[])
  into roles_text
  from (
    select jsonb_array_elements_text(auth.jwt() -> 'user_roles') as x
  ) t;

  return exists (
    select 1
    from identity.role_permissions rp
    where rp.permission = requested_permission
      and rp.role::text = any(roles_text)
      and rp.is_active
  );
end;
$$;

-- -----------------------------------------------------------------------------
-- Auth hook: populate org + membership + roles claims
-- Notes:
-- - current_org_id is stored in auth.users.raw_user_meta_data.current_org_id
-- - If missing, picks first active org membership (owners first)
-- - Populates user_roles array (multi-role)
-- -----------------------------------------------------------------------------
create or replace function identity.custom_access_token_hook(
  event jsonb
) returns jsonb
language plpgsql
security definer
set search_path = public, pg_temp
as $$
declare
  claims jsonb;
  current_org_id uuid;
  current_member_id bigint;
  user_roles_arr identity.app_role[];
  role_ids_arr bigint[];
  org_ids_arr uuid[];
  is_owner boolean;
  org_slug text;
begin
  claims := coalesce(event->'claims', '{}'::jsonb);

  -- Determine current org
  current_org_id := coalesce(
    (event->'user_metadata'->>'current_org_id')::uuid,
    (
      select om.org_id
      from identity.org_member om
      where om.user_id = (event->>'user_id')::uuid
        and om.is_active = true
      order by om.is_owner desc, om.created_at asc
      limit 1
    )
  );

  if current_org_id is not null then
    select o.slug
      into org_slug
    from identity.org o
    where o.id = current_org_id
      and o.is_active = true;
  end if;

  -- Membership for current org
  if current_org_id is not null then
    select om.id, om.is_owner
      into current_member_id, is_owner
    from identity.org_member om
    where om.user_id = (event->>'user_id')::uuid
      and om.org_id = current_org_id
      and om.is_active = true;
  end if;

  -- Roles for membership
  if current_member_id is not null then
    select
      array_agg(mr.role) filter (where mr.is_active = true),
      array_agg(mr.id) filter (where mr.is_active = true)
    into user_roles_arr, role_ids_arr
    from identity.member_role mr
    where mr.member_id = current_member_id
      and mr.is_active = true;
  end if;

  -- All org memberships
  select array_agg(om.org_id)
    into org_ids_arr
  from identity.org_member om
  where om.user_id = (event->>'user_id')::uuid
    and om.is_active = true;

  claims := jsonb_set(claims, '{org_id}', coalesce(to_jsonb(current_org_id), 'null'::jsonb));
  claims := jsonb_set(claims, '{org_slug}', coalesce(to_jsonb(org_slug), 'null'::jsonb));
  claims := jsonb_set(claims, '{member_id}', coalesce(to_jsonb(current_member_id), 'null'::jsonb));
  claims := jsonb_set(claims, '{user_roles}', coalesce(to_jsonb(user_roles_arr), '[]'::jsonb));
  claims := jsonb_set(claims, '{role_ids}', coalesce(to_jsonb(role_ids_arr), '[]'::jsonb));
  claims := jsonb_set(claims, '{org_ids}', coalesce(to_jsonb(org_ids_arr), '[]'::jsonb));
  claims := jsonb_set(claims, '{is_org_owner}', to_jsonb(coalesce(is_owner, false)));

  -- Update event
  event := jsonb_set(event, '{claims}', claims);
  return event;
end;
$$;

-- Ensure supabase auth admin can execute hook and read roles/members
grant usage on schema identity to supabase_auth_admin;

grant execute on function identity.custom_access_token_hook to supabase_auth_admin;
revoke execute on function identity.custom_access_token_hook from authenticated, anon;

-- Allow auth admin to read membership + roles (for hook)
grant all on table identity.org_member to supabase_auth_admin;
grant all on table identity.member_role to supabase_auth_admin;
grant all on table identity.org to supabase_auth_admin;

revoke all on table identity.org_member from authenticated, anon;
revoke all on table identity.member_role from authenticated, anon;
revoke all on table identity.org from authenticated, anon;

create policy "Allow auth admin to read org members" on identity.org_member
as permissive for select
to supabase_auth_admin
using (true);

create policy "Allow auth admin to read member roles" on identity.member_role
as permissive for select
to supabase_auth_admin
using (true);

create policy "Allow auth admin to read orgs" on identity.org
as permissive for select
to supabase_auth_admin
using (true);

-- Enable RLS on new tables
alter table identity.org enable row level security;
alter table identity.org_member enable row level security;
alter table identity.member_role enable row level security;

commit;
